<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Quest - A JavaScript Adventure</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Source+Code+Pro:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css">

    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        .font-game {
            font-family: 'Press Start 2P', cursive;
        }
        .font-code {
            font-family: 'Source Code Pro', monospace;
        }
        /* Custom scrollbar for webkit browsers */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #1f2937;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #4f46e5;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #6366f1;
        }
        .lesson-item.active {
            background-color: #4f46e5;
            color: white;
        }
        #character {
            transition: all 0.5s ease-in-out;
            transform-origin: bottom center;
        }
        .character-jump {
            animation: jump 0.5s ease-in-out;
        }
        @keyframes jump {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        #target-coin {
            animation: spin 1s linear infinite, bob 2s ease-in-out infinite;
            transform-origin: center center;
            font-size: 1.75rem; /* 28px */
            text-shadow: 0 0 10px #facc15;
        }
        @keyframes spin {
            from { transform: rotateY(0deg); }
            to { transform: rotateY(360deg); }
        }
        @keyframes bob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .obstacle-wall {
            background-color: #78716c; /* stone-500 */
            border: 2px solid #44403c; /* stone-700 */
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        /* CodeMirror Styling */
        .CodeMirror {
            font-family: 'Source Code Pro', monospace;
            font-size: 14px;
            height: 100%;
            background: #262626; /* neutral-800 */
            color: #d4d4d4; /* neutral-300 */
        }
        .cm-s-material-darker.CodeMirror {
            background-color: #1f2937; /* gray-800 */
        }
        .CodeMirror-gutters {
            background: #1f2937 !important; /* gray-800 */
            border-right: 1px solid #374151; /* gray-700 */
        }
        .CodeMirror-cursor {
            border-left: 1px solid #f472b6; /* pink-400 */
        }

        /* Project Manager Styles */
        .project-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background-color: #374151; /* gray-700 */
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        .project-item:hover {
            background-color: #4b5563; /* gray-600 */
        }
        .project-item-name {
            cursor: pointer;
            flex-grow: 1;
        }
        .project-delete-btn {
            background: none;
            border: none;
            color: #ef4444; /* red-500 */
            cursor: pointer;
            font-size: 1.25rem;
            padding: 4px;
        }
        .project-delete-btn:hover {
            color: #f87171; /* red-400 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col p-4 gap-4">

    <!-- Header -->
    <header class="text-center">
        <h1 class="font-game text-3xl text-yellow-400 drop-shadow-lg">Code Quest</h1>
        <p class="text-gray-400">Your JavaScript Adventure Begins!</p>
    </header>

    <!-- Main Content -->
    <main id="main-grid" class="flex-1 grid gap-4 min-h-0" style="grid-template-columns: 1fr 1fr 1fr;">

        <!-- Left Panel: Lessons & Instructions (Minimizable) -->
        <div id="left-panel" class="bg-gray-800 rounded-xl shadow-2xl flex flex-col overflow-hidden transition-all duration-300">
            <div class="flex items-center justify-between p-4 bg-gray-700 text-green-400 border-b-2 border-gray-600">
                <button id="toggle-missions" class="p-1 hover:bg-gray-600 rounded-md">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                </button>
                <h2 id="missions-title" class="font-game text-lg">Missions</h2>
                <button id="reset-lesson-code" class="p-1 hover:bg-gray-600 rounded-md" title="Reset lesson code to default">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m-15.357-2A8.001 8.001 0 0019.418 15m0 0H15" />
                    </svg>
                </button>
            </div>
            
            <div id="left-panel-content" class="flex flex-col min-h-0">
                <!-- Lesson List View -->
                <div id="lesson-view" class="flex flex-col min-h-0">
                    <ul id="lessons-list" class="p-4 space-y-2 overflow-y-auto custom-scrollbar" style="max-height: 40%;">
                        <!-- Lessons will be dynamically inserted here -->
                    </ul>
                    <div class="flex-1 p-4 border-t-2 border-gray-600 bg-gray-800/50 flex flex-col min-h-0 custom-scrollbar overflow-y-auto">
                         <h3 id="instruction-title" class="font-game text-md text-cyan-400 mb-2">Select a Mission!</h3>
                         <div id="instruction-text" class="text-gray-300 mb-4 pr-2 flex-grow">
                             Welcome, Coder! Choose a mission from the list to get started. Your instructions will appear here. Good luck!
                         </div>
                         <h3 class="font-game text-md text-yellow-300 border-t-2 border-gray-700 pt-4 mt-4">Available Commands</h3>
                         <div id="command-list" class="pt-4 space-y-2">
                             <!-- Available commands will be populated here -->
                         </div>
                    </div>
                </div>

                <!-- Project Manager View (Initially hidden) -->
                <div id="project-view" class="p-4 flex-col min-h-0 custom-scrollbar overflow-y-auto hidden">
                    <h3 class="font-game text-md text-cyan-400 mb-4">My Projects</h3>
                    <div class="mb-4">
                        <input id="new-project-name" type="text" placeholder="New project name..." class="font-code w-full p-2 rounded bg-gray-900 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <button id="create-project-btn" class="w-full mt-2 py-2 bg-green-600 hover:bg-green-700 font-game text-sm transition-colors">CREATE</button>
                    </div>
                    <div id="project-list-container" class="space-y-2">
                        <!-- Saved projects will be listed here -->
                    </div>
                </div>

            </div>
        </div>

        <!-- Middle Panel: Game World -->
        <div id="game-panel" class="bg-gray-800 rounded-xl shadow-2xl flex flex-col items-center justify-center p-4 relative overflow-hidden transition-all duration-300">
            <h2 class="font-game text-lg absolute top-4 text-purple-400">Game World</h2>
            <div id="game-world" class="w-full h-full bg-grid-pattern relative border-2 border-gray-600 rounded-lg" style="background-image: linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px); background-size: 40px 40px;">
                <!-- Character -->
                <div id="character" class="w-10 h-10 absolute rounded-lg flex items-center justify-center text-2xl" style="left: 50px; top: 50px; background-color: #fbbf24;">
                    ü§ñ
                </div>
                <!-- Character Speech -->
                <div id="character-speech" class="absolute hidden bg-white text-black p-2 rounded-lg text-sm" style="transform: translate(-50%, -120%); z-index: 10;"></div>
                <!-- Game Target -->
                <div id="target-coin" class="w-10 h-10 absolute flex items-center justify-center" style="left: 200px; top: 150px; display: none;">
                    ü™ô
                </div>
                <!-- Obstacles Container -->
                <div id="obstacle-container"></div>
            </div>
        </div>

        <!-- Right Panel: Code Editor & Console -->
        <div id="editor-panel" class="bg-gray-800 rounded-xl shadow-2xl flex flex-col overflow-hidden transition-all duration-300">
            <h2 class="font-game text-lg p-4 bg-gray-700 text-red-400 border-b-2 border-gray-600">Code Editor</h2>
            <div class="flex-1 flex flex-col min-h-0">
                <textarea id="code-editor" class="flex-1 bg-gray-900 p-4 text-cyan-300 font-code text-sm w-full h-full resize-none focus:outline-none custom-scrollbar" spellcheck="false">
// Welcome to Code Quest!
// Select a mission from the left panel to get started.
// Your code goes here.
</textarea>
                <!-- Button container -->
                <div class="flex">
                    <button id="run-button" class="w-1/3 py-2 bg-indigo-600 hover:bg-indigo-700 font-game text-sm transition-colors">RUN</button>
                    <button id="debug-button" class="w-1/3 py-2 bg-blue-600 hover:bg-blue-700 font-game text-sm transition-colors border-l border-r border-gray-900">DEBUG</button>
                    <button id="step-button" class="w-1/3 py-2 bg-yellow-500 hover:bg-yellow-600 font-game text-sm transition-colors hidden">STEP</button>
                    <button id="reset-button" class="w-1/3 py-2 bg-red-600 hover:bg-red-700 font-game text-sm transition-colors">RESET</button>
                </div>
            </div>
            <div class="flex flex-col border-t-2 border-gray-600" style="height: 35%;">
                <!-- Debugger -->
                <div class="flex-1 flex flex-col min-h-0">
                    <h3 class="font-game text-sm p-2 bg-gray-700 text-cyan-300">Execution Step</h3>
                    <div id="debugger-output" class="flex-1 bg-black p-2 text-sm font-code overflow-y-auto custom-scrollbar flex items-center justify-center">
                        <span class="text-gray-500">Press RUN or DEBUG...</span>
                    </div>
                </div>
                <!-- Console -->
                <div class="flex-1 flex flex-col min-h-0 border-t-2 border-gray-600">
                    <h3 class="font-game text-sm p-2 bg-gray-700 text-yellow-300">Console</h3>
                    <div id="console-output" class="flex-1 bg-black p-2 text-xs font-code overflow-y-auto custom-scrollbar">
                        <span class="text-gray-500">> Console ready...</span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Modal for 'ask' function -->
    <div id="ask-modal" class="absolute inset-0 bg-black/70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl font-game border-2 border-indigo-500">
            <h3 id="ask-prompt" class="text-lg text-cyan-400 mb-4">Question?</h3>
            <input id="ask-input" type="text" class="font-code w-full p-2 rounded bg-gray-900 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
            <button id="ask-submit" class="w-full mt-4 py-2 bg-indigo-600 hover:bg-indigo-700 font-game text-lg transition-colors">SUBMIT</button>
        </div>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const lessonsList = document.getElementById('lessons-list');
        const commandList = document.getElementById('command-list');
        const instructionTitle = document.getElementById('instruction-title');
        const instructionText = document.getElementById('instruction-text');
        const gameWorld = document.getElementById('game-world');
        const character = document.getElementById('character');
        const characterSpeech = document.getElementById('character-speech');
        const runButton = document.getElementById('run-button');
        const debugButton = document.getElementById('debug-button');
        const stepButton = document.getElementById('step-button');
        const resetButton = document.getElementById('reset-button');
        const consoleOutput = document.getElementById('console-output');
        const debuggerOutput = document.getElementById('debugger-output');
        const targetCoin = document.getElementById('target-coin');
        const obstacleContainer = document.getElementById('obstacle-container');
        
        // Modal elements
        const askModal = document.getElementById('ask-modal');
        const askPrompt = document.getElementById('ask-prompt');
        const askInput = document.getElementById('ask-input');
        const askSubmit = document.getElementById('ask-submit');
        
        // Layout elements
        const mainGrid = document.getElementById('main-grid');
        const leftPanel = document.getElementById('left-panel');
        const leftPanelContent = document.getElementById('left-panel-content');
        const gamePanel = document.getElementById('game-panel');
        const editorPanel = document.getElementById('editor-panel');
        const toggleMissions = document.getElementById('toggle-missions');
        const resetLessonCodeBtn = document.getElementById('reset-lesson-code');
        const missionsTitle = document.getElementById('missions-title');

        // Project Manager elements
        const lessonView = document.getElementById('lesson-view');
        const projectView = document.getElementById('project-view');
        const newProjectName = document.getElementById('new-project-name');
        const createProjectBtn = document.getElementById('create-project-btn');
        const projectListContainer = document.getElementById('project-list-container');


        // --- CODEMIRROR SETUP ---
        const editor = CodeMirror.fromTextArea(document.getElementById('code-editor'), {
            lineNumbers: true,
            mode: 'javascript',
            theme: 'material-darker',
            autoCloseBrackets: true,
            matchBrackets: true
        });

        // --- APP STATE ---
        let commandQueue = [];
        let isExecuting = false;
        let isDebugging = false;
        let stepPromiseResolver = null;
        let inputPromiseResolver = null;
        let activeLessonIndex = -1;
        let activeProjectKey = null; // e.g., "codeQuestProject_MyProject"
        let savedProjects = {}; // Will be loaded from localStorage

        let characterState = { x: 50, y: 50, color: '#fbbf24', emoji: 'ü§ñ' };
        let targetState = { x: 200, y: 150, isVisible: false };
        let wallStates = [];

        // --- GAME CHARACTER FUNCTIONS (API for the user) ---
        // We must use 'async function' to allow 'await' for animations
        
        /**
         * Moves the character down.
         */
        async function moveDown(steps = 50) {
            const commandString = `moveDown(${steps})`;
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return;
            logToConsole(`Moving down by ${steps}px...`);
            const worldHeight = gameWorld.clientHeight;
            characterState.y = Math.min(worldHeight - character.offsetHeight, characterState.y + steps);
            updateCharacter();
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        /**
         * Moves the character up.
         */
        async function moveUp(steps = 50) {
            const commandString = `moveUp(${steps})`;
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return;
            logToConsole(`Moving up by ${steps}px...`);
            characterState.y = Math.max(0, characterState.y - steps);
            updateCharacter();
            character.classList.add('character-jump');
            await new Promise(resolve => setTimeout(resolve, 500));
            character.classList.remove('character-jump');
        }

        /**
         * Moves the character right.
         */
        async function moveRight(steps = 50) {
            const commandString = `moveRight(${steps})`;
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return;
            logToConsole(`Moving right by ${steps}px...`);
            const worldWidth = gameWorld.clientWidth;
            characterState.x = Math.min(worldWidth - character.offsetWidth, characterState.x + steps);
            updateCharacter();
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        /**
         * Moves the character left.
         */
        async function moveLeft(steps = 50) {
            const commandString = `moveLeft(${steps})`;
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return;
            logToConsole(`Moving left by ${steps}px...`);
            characterState.x = Math.max(0, characterState.x - steps);
            updateCharacter();
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        /**
         * Moves the character to a specific x, y coordinate.
         */
        async function moveTo(x, y) {
            const commandString = `moveTo(${x}, ${y})`;
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return;
            logToConsole(`Moving to (${x}, ${y})...`);
            const worldHeight = gameWorld.clientHeight;
            const worldWidth = gameWorld.clientWidth;
            
            characterState.x = Math.max(0, Math.min(worldWidth - character.offsetWidth, x));
            characterState.y = Math.max(0, Math.min(worldHeight - character.offsetHeight, y));
            
            updateCharacter();
            await new Promise(resolve => setTimeout(resolve, 700)); // moveTo is a bit slower
        }


        /**
         * Changes the character's color.
         */
        async function changeColor(newColor) {
            const commandString = `changeColor('${newColor}')`;
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return;
            logToConsole(`Changing color to ${newColor}...`);
            characterState.color = newColor;
            updateCharacter();
            await new Promise(resolve => setTimeout(resolve, 200));
        }

        /**
         * Changes the character's emoji.
         */
        async function changeCharacter(newEmoji) {
            const commandString = `changeCharacter('${newEmoji}')`;
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return;
            logToConsole(`Changing character to ${newEmoji}...`);
            characterState.emoji = newEmoji;
            updateCharacter();
            await new Promise(resolve => setTimeout(resolve, 200));
        }

        /**
         * Makes the character say something in a speech bubble.
         */
        async function say(message) {
            const displayMessage = String(message).replace(/'/g, "\\'").replace(/"/g, '\\"');
            const commandString = `say('${displayMessage}')`;
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return;
            
            logToConsole(`Character says: ${message}`);
            characterSpeech.innerText = message;
            characterSpeech.style.display = 'block';
            characterSpeech.style.left = `${characterState.x + character.offsetWidth / 2}px`;
            characterSpeech.style.top = `${characterState.y}px`;
            await new Promise(resolve => setTimeout(resolve, 2000));
            characterSpeech.style.display = 'none';
        }

        /**
         * Logs a variable's value to the debugger window.
         * e.g., await watch("myVariable", myVariable);
         */
        async function watch(label, value) {
            let valueString;
            try {
                // Stringify objects/arrays for better display
                if (typeof value === 'object' && value !== null) {
                    valueString = JSON.stringify(value);
                } else if (typeof value === 'string') {
                    valueString = `'${value}'`; // Add quotes to strings
                } else {
                    valueString = String(value);
                }
            } catch (e) {
                valueString = String(value);
            }
            
            const commandString = `watch('${label}', ${valueString})`;
            
            // In debug mode, we pause BEFORE showing the value
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return;

            const output = `<span class="text-pink-400">${String(label)}:</span> <span class="text-yellow-300">${valueString}</span>`;
            debuggerOutput.innerHTML = output;
            logToConsole(`WATCH: ${label} = ${valueString}`);
            
            // Short pause so the user can see the value, even in run mode
            await new Promise(resolve => setTimeout(resolve, isDebugging ? 100 : 500));
        }


        /**
         * Asks the user for input via a modal.
         */
        async function ask(message) {
            const commandString = `ask('${message}')`;
            // We must pause *before* showing the modal in debug mode
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return;

            logToConsole(`Asking user: ${message}`);
            askModal.classList.remove('hidden');
            askPrompt.textContent = message;
            askInput.value = '';
            askInput.focus();

            return new Promise((resolve) => {
                inputPromiseResolver = resolve;
            });
        }

        /**
         * Returns the {x, y} coordinates of the target coin.
         */
        function getTargetPosition() {
            // Note: This function is NOT async. It returns a value immediately.
            // No need to "await" it, and no debug step.
            logToConsole(`Getting target position: {x: ${targetState.x}, y: ${targetState.y}}`);
            return { x: targetState.x, y: targetState.y };
        }

        /**
         * Checks if the character is colliding with any wall.
         * Returns true or false.
         */
        async function checkCollision() {
            const commandString = `checkCollision()`;
            if (isDebugging) await waitForStep(commandString);
            if (!isExecuting) return false;

            logToConsole('Checking for collision...');
            const charRect = character.getBoundingClientRect();
            let isColliding = false;

            document.querySelectorAll('.obstacle-wall').forEach(wall => {
                const wallRect = wall.getBoundingClientRect();
                // Simple AABB collision check
                if (
                    charRect.left < wallRect.right &&
                    charRect.right > wallRect.left &&
                    charRect.top < wallRect.bottom &&
                    charRect.bottom > wallRect.top
                ) {
                    isColliding = true;
                }
            });

            if (isColliding) {
                logToConsole('Collision detected!', 'error');
                await changeCharacter('üòµ');
            } else {
                logToConsole('No collision.');
            }
            
            await new Promise(resolve => setTimeout(resolve, 300)); // Small delay
            return isColliding;
        }


        // --- INTERNAL FUNCTIONS ---

        /**
         * Pauses execution and waits for the 'Step' button to be pressed.
         */
        function waitForStep(commandString) {
            debuggerOutput.innerHTML = `<span class="text-yellow-400">${commandString}</span>`;
            
            // Show STEP, hide DEBUG
            debugButton.classList.add('hidden');
            stepButton.classList.remove('hidden');

            return new Promise((resolve) => {
                stepPromiseResolver = resolve;
            });
        }

        /**
         * Updates the character's position, color, and emoji in the DOM.
         */
        function updateCharacter() {
            character.style.left = `${characterState.x}px`;
            character.style.top = `${characterState.y}px`;
            character.style.backgroundColor = characterState.color;
            character.innerHTML = characterState.emoji;
        }

        /**
         * Updates the game world objects (coins, walls) based on state.
         */
        function updateGameWorld() {
            // Update target
            if (targetState.isVisible) {
                targetCoin.style.left = `${targetState.x}px`;
                targetCoin.style.top = `${targetState.y}px`;
                targetCoin.style.display = 'flex';
            } else {
                targetCoin.style.display = 'none';
            }

            // Update walls
            obstacleContainer.innerHTML = '';
            wallStates.forEach(wall => {
                const wallEl = document.createElement('div');
                wallEl.className = 'obstacle-wall absolute';
                wallEl.style.left = `${wall.x}px`;
                wallEl.style.top = `${wall.y}px`;
                wallEl.style.width = `${wall.width}px`;
                wallEl.style.height = `${wall.height}px`;
                obstacleContainer.appendChild(wallEl);
            });
        }

        /**
         * Resets the character and game world to its initial state.
         */
        function resetCharacter() {
            logToConsole('Resetting character state...');
            characterState = { x: 50, y: 50, color: '#fbbf24', emoji: 'ü§ñ' };
            updateCharacter();
            updateGameWorld(); // Also resets coins/walls
            characterSpeech.style.display = 'none';
        }

        /**
         * Fully stops execution, clears queues, and resets UI.
         */
        function stopExecution() {
            isExecuting = false;
            isDebugging = false;

            // If we were waiting for a step, resolve the promise to stop it
            if (stepPromiseResolver) {
                stepPromiseResolver();
                stepPromiseResolver = null;
            }
            // If we were waiting for input, resolve it with 'null'
            if (inputPromiseResolver) {
                inputPromiseResolver(null);
                inputPromiseResolver = null;
                askModal.classList.add('hidden');
            }
            
            commandQueue = [];

            // Reset UI
            debuggerOutput.innerHTML = '<span class="text-gray-500">Execution Stopped.</span>';
            runButton.disabled = false;
            debugButton.disabled = false;
            runButton.classList.remove('opacity-50', 'cursor-not-allowed');
            debugButton.classList.remove('opacity-50', 'cursor-not-allowed');

            stepButton.classList.add('hidden');
            debugButton.classList.remove('hidden');
            resetButton.textContent = 'RESET';
        }

        /**
         * Logs a message to the in-app console.
         */
        function logToConsole(message, type = 'info') {
            const span = document.createElement('span');
            if (type === 'error') {
                span.className = 'text-red-500';
                span.textContent = `> Error: ${message}`;
            } else if (type === 'success') {
                span.className = 'text-green-400';
                span.textContent = `> ${message}`;
            } else {
                span.className = 'text-gray-400';
                span.textContent = `> ${message}`;
            }
            consoleOutput.appendChild(document.createElement('br'));
            consoleOutput.appendChild(span);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }

        /**
         * Gathers and executes the user's code.
         */
        async function executeCode(runInDebugMode = false) {
            if (isExecuting) return;

            isExecuting = true;
            isDebugging = runInDebugMode;
            
            commandQueue = [];
            consoleOutput.innerHTML = '';
            logToConsole('Parsing code...');
            debuggerOutput.innerHTML = '<span class="text-gray-500">Parsing...</span>';
            resetCharacter();

            // Disable buttons
            runButton.disabled = true;
            debugButton.disabled = true;
            runButton.classList.add('opacity-50', 'cursor-not-allowed');
            debugButton.classList.add('opacity-50', 'cursor-not-allowed');
            
            // "Reset" button becomes "Stop"
            resetButton.textContent = 'STOP';

            // We need to wrap the user's code in an async function
            // to allow top-level 'await'
            const userCode = editor.getValue();
            
            // Create a "sandboxed" async function
            // This is the key to letting `await` work
            const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
            
            // We pass our game functions as arguments to the sandboxed function
            const userFunc = new AsyncFunction(
                'moveDown', 'moveUp', 'moveRight', 'moveLeft',
                'changeColor', 'changeCharacter', 'say', 'ask',
                'watch', 'moveTo', 'getTargetPosition', 'checkCollision',
                userCode
            );

            try {
                // Call the user's code
                await userFunc(
                    moveDown, moveUp, moveRight, moveLeft,
                    changeColor, changeCharacter, say, ask,
                    watch, moveTo, getTargetPosition, checkCollision
                );
                
                if (isExecuting) { // Only show "Complete" if it wasn't stopped
                    debuggerOutput.innerHTML = `<span class="text-green-400">Execution Complete!</span>`;
                    logToConsole('Code finished successfully!', 'success');
                }
            } catch (error) {
                logToConsole(error.message, 'error');
                debuggerOutput.innerHTML = `<span class="text-red-500">Error! Check console.</span>`;
            } finally {
                stopExecution();
            }
        }


        // --- LESSON DATA (EXPANDED) ---
        // (Note: Lesson 31 is now the Project Manager)
        const lessons = [
            // Module 1: The Basics
            { title: "1. Functions: Giving Commands", explanation: "Think of a function as a single, saved command you can give. In our game, we have built-in commands like <strong>moveRight()</strong>. You 'call' a function by typing its name followed by parentheses <strong>()</strong>. Because our commands have animations, you <strong>must</strong> tell the code to 'wait' for it to finish. You do this by writing the <strong>await</strong> keyword before the command. Every command must end with a semicolon <strong>;</strong>.", starterCode: `// 'await' tells the code to wait for the command to finish.\nawait moveRight();` },
            { title: "2. Variables: Storing Info", explanation: "A variable is like a labeled box for storing information. You create one with the keyword <strong>let</strong>, give it a name, and use <strong>=</strong> to put something inside. This is useful for saving data you want to use later, like a favorite color.", starterCode: `// let creates a new variable named 'myColor'.\n// We put the text 'purple' inside it.\nlet myColor = 'purple';\n\n// Now we use the variable's value.\nawait changeColor(myColor);` },
            { title: "3. The Watcher (Debug)", explanation: "Want to know what's in a variable while your code runs? Use the <strong>await watch()</strong> command! It takes two arguments: a 'label' (as a string) and the variable you want to see. It will print the value directly to the 'Execution Step' window.", starterCode: `await say("Let's watch a variable change.");\nlet points = 100;\n\nawait watch('Initial Points', points);\n\npoints = points + 50;\n\nawait watch('Final Points', points);\nawait say("I have " + points + " points!");` },
            { title: "4. Data Types: Text (Strings)", explanation: "In programming, text is called a 'string'. To make sure the computer knows it's text, you must wrap it in single <strong>' '</strong> or double <strong>\" \"</strong> quotes. Anything inside the quotes is treated as a single piece of text, even if it has spaces or numbers.", starterCode: `// The text inside the quotes is a string.\nawait say('Hello, I am a robot!');` },
            { title: "5. Functions with Arguments", explanation: "An 'argument' is extra information you give to a function to change what it does. You put the argument inside the parentheses <strong>()</strong>. For example, <strong>moveRight(100)</strong> tells the move function to go 100 steps instead of the default 50.", starterCode: `// 'green' is the argument for the color.\nawait changeColor('green');\n\n// 150 is the argument for the steps.\nawait moveRight(150);\nawait moveDown(25);` },
            { title: "6. Getting User Input (await)", explanation: "You can ask the user for information! The <strong>ask()</strong> function will pause the game and show a popup. Because it has to wait for the user, you must use the <strong>await</strong> keyword before it to capture the value. The value is then stored in your variable.", starterCode: `// 'await' pauses the code until the user answers.\nawait say("Who are you?");\nlet name = await ask("What's your name?");\nawait say("Hello, " + name + "!");` },
            
            // Module 2: Logic and Loops
            { title: "7. Loops: Repeating Actions", explanation: "A loop tells the computer to repeat a block of code multiple times. A <strong>for</strong> loop is perfect for this. The code <strong>for (let i = 0; i < 4; i++) { ... }</strong> sets up a counter 'i' and runs the code in the curly braces <strong>{ }</strong> as long as 'i' is less than 4.", starterCode: `// This loop will run its code 4 times.\nawait say('Here I go!');\nfor (let i = 0; i < 4; i++) {\n  await moveRight(50);\n}` },
            { title: "8. Coordinates (Objects)", explanation: "The game world uses coordinates (x, y) to know where things are. You can get the position of the coin ü™ô using <strong>getTargetPosition()</strong>. This gives you an 'object' (like a variable box holding other variables). You can access the values inside using a dot <strong>.</strong>, like <strong>target.x</strong> and <strong>target.y</strong>.", starterCode: `await say("Where is that coin?");\nlet targetPos = getTargetPosition();\nawait watch("Target Position", targetPos);\nawait say("It's at x: " + targetPos.x + " and y: " + targetPos.y);\n\n// Now, let's go get it!\nawait moveTo(targetPos.x, targetPos.y);\nawait say("Got it!");` },
            { title: "9. Conditionals: Making Choices", explanation: "Conditional logic using <strong>if...else</strong> lets your program make decisions. The code inside the <strong>if { }</strong> block runs only IF the condition in the parentheses is true. If it's false, the code in the <strong>else { }</strong> block runs instead.", starterCode: `let score = 200;\n\n// The 'if' condition checks if score is greater than 100.\nif (score > 100) {\n  await changeCharacter('üèÜ');\n  await say('I am a winner!');\n} else {\n  await say('I need more points!');\n}` },
            { title: "10. Booleans & Collision", explanation: "A 'boolean' is the simplest data type: just <strong>true</strong> or <strong>false</strong>. The <strong>await checkCollision()</strong> command returns a boolean. It checks if you are touching a wall and gives you <strong>true</strong> if you are, or <strong>false</strong> if you aren't. This is perfect for an <strong>if</strong> statement!", starterCode: `await say("Let's move right...");\nawait moveRight(150);\n\nlet amITouchingWall = await checkCollision();\nawait watch("Touching Wall?", amITouchingWall);\n\nif (amITouchingWall === true) {\n  await say("Ouch! A wall!");\n  // 'await changeCharacter' is already done by checkCollision()\n  await moveLeft(100);\n} else {\n  await say("All clear!");\n}` },
            { title: "11. Challenge: Draw a Square", explanation: "Let's combine what you've learned! To draw a square, you need to repeat two actions four times: move a certain distance, and then turn. Think about which two movement commands you'd need to use inside a loop that runs 4 times.", starterCode: `// CHALLENGE: Make the character move in a square shape.\nawait say("Time to draw!");\n\nfor (let i = 0; i < 4; i++) {\n  // What two commands go here to make a square?\n  await moveRight(100);\n  await moveDown(100);\n}` },
            
            // Module 3: Deeper Concepts
            { title: "12. Data Types: Numbers & Math", explanation: "Besides strings, you can also store numbers. You don't need quotes for numbers. You can also do math right inside your code using operators like <strong>+</strong> (add), <strong>-</strong> (subtract), <strong>*</strong> (multiply), and <strong>/</strong> (divide).", starterCode: `// You can do math with numbers.\nlet distance = 25 * 4; // This equals 100\n\nawait say('I will move 100 steps.');\nawait moveRight(distance);\n\n// You can even do math in the function call!\nawait moveDown(50 + 50);` },
            { title: "13. Data Types: Booleans (Recap)", explanation: "A boolean is the simplest data type: it can only be <strong>true</strong> or <strong>false</strong>. Booleans are the heart of decision-making. An <strong>if</strong> statement always checks if a condition is true or false.", starterCode: `let isFriendly = true;\n\nif (isFriendly) {\n  await changeCharacter('üòä');\n  await say('Nice to meet you!');\n} else {\n  await changeCharacter('üò†');\n  await say('Go away!');\n}` },
            { title: "14. Comparison Operators", explanation: "How does an 'if' statement know if something is true? By using comparison operators! <strong>></strong> (greater than), <strong><</strong> (less than), and <strong>===</strong> (equal to) are used to compare two values.", starterCode: `let myLevel = 5;\n\n// This checks if myLevel is exactly equal to 5.\nif (myLevel === 5) {\n  await say('Level 5 unlocked!');\n}\n\nawait moveRight(100);\n\n// This checks if myLevel is less than 10.\nif (myLevel < 10) {\n  await say('I am still a beginner.');\n}` },
            { title: "15. Logical Operators: AND", explanation: "What if you need to check two conditions at once? The AND operator, <strong>&&</strong>, lets you do that. The whole condition is only true if the conditions on BOTH sides of the && are true.", starterCode: `let level = 12;\nlet hasKey = true;\n\n// We need to be level 10+ AND have the key to enter.\nif (level > 10 && hasKey === true) {\n  await changeCharacter('üîë');\n  await say('The door is open!');\n} else {\n  await say('I cannot enter.');\n}` },
            { title: "16. Logical Operators: OR", explanation: "The OR operator, <strong>||</strong>, is the opposite of AND. It checks if at least ONE of the conditions is true. The whole condition is true if the left side is true, OR if the right side is true (or if both are).", starterCode: `let coins = 5;\nlet gems = 2;\n\n// I can afford the item if I have 10 coins OR 3 gems.\nif (coins >= 10 || gems >= 3) {\n  await say('I can buy the shield!');\n} else {\n  await say('Not enough money!');\n}` },
            
            // Module 4: Arrays
            { title: "17. Arrays: Making Lists", explanation: "An array is a special variable that can hold a list of items. You create an array using square brackets <strong>[ ]</strong>, and separate each item with a comma. This is great for storing collections of related data.", starterCode: `// An array of strings holding different colors.\nlet rainbowColors = ['red', 'orange', 'yellow', 'green', 'blue'];\n\n// An array of numbers.\nlet movementSteps = [50, 100, 25];\n\nawait say('I know my colors!');` },
            { title: "18. Arrays: Accessing Items", explanation: "To get an item from an array, you use its 'index' number. The index is its position in the list, but be careful: **counting starts at 0!** So, the first item is at index <strong>[0]</strong>, the second is at <strong>[1]</strong>, and so on.", starterCode: `let emojiList = ['ü§ñ', 'üöÄ', '‚≠ê', 'üçï'];\n\n// Get the second item (at index 1).\nlet rocket = emojiList[1];\nawait changeCharacter(rocket);\n\nawait say('To the moon!');` },
            { title: "19. Arrays: The .length Property", explanation: "Every array has a built-in property called <strong>.length</strong> that tells you how many items are inside it. This is incredibly useful, especially when you want a loop to run for every item in an array.", starterCode: `let patrolRoute = [100, 50, 100, 50];\n\nlet numberOfMoves = patrolRoute.length;\n\nawait say('My route has ' + numberOfMoves + ' moves.');` },
            { title: "20. Looping Through Arrays", explanation: "Now let's combine loops and arrays! You can use a <strong>for</strong> loop to go through every single item in an array. A common pattern is to make the loop run as long as the counter is less than the array's length.", starterCode: `let colorSequence = ['#ef4444', '#f97316', '#eab308', '#22c55e'];\n\n// This loop will run for every color in the array.\nfor (let i = 0; i < colorSequence.length; i++) {\n  let currentColor = colorSequence[i];\n  await changeColor(currentColor);\n  await moveRight(60);\n}` },
            { title: "21. Challenge: Rainbow Road", explanation: "Use your knowledge of arrays and loops to make the character move across the screen, changing to each color of the rainbow as it goes. You'll need an array of colors and a for loop!", starterCode: `let rainbow = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\nawait say('Taste the rainbow!');\n\n// CHALLENGE: Write a 'for' loop that goes through the 'rainbow' array.\n// Inside the loop, change the character's color and move it right.\nfor (let i = 0; i < rainbow.length; i++) {\n  await changeColor(rainbow[i]);\n  await moveRight(50);\n}` },
            
            // Module 5: Your Own Functions
            { title: "22. Create Your Own Functions", explanation: "You're not limited to our built-in commands! You can create your own reusable blocks of code using the <strong>function</strong> keyword. <strong>Important:</strong> If you use <strong>await</strong> inside your new function, you must declare your function as <strong>async</strong> by writing <strong>async function...</strong>", starterCode: `// This defines a new async function, but doesn't run it yet.\nasync function jump() {\n  await moveUp(50);\n  await moveDown(50);\n}\n\n// Now, we can call our new function just like the others!\nawait say('Time to jump!');\nawait jump();\nawait moveRight(100);\nawait jump();` },
            { title: "23. Functions with Parameters", explanation: "You can make your functions more powerful by letting them accept inputs, just like ours do. These inputs are called 'parameters'. You define them in the parentheses when you create the function.", starterCode: `// 'distance' is a parameter. Its value will be whatever we give it when we call the function.\nasync function moveInSquare(distance) {\n  await moveRight(distance);\n  await moveDown(distance);\n  await moveLeft(distance);\n  await moveUp(distance);\n}\n\n// Call the function and give it 100 as the argument for 'distance'.\nawait moveInSquare(100);` },
            { title: "24. Challenge: Create a Patrol Bot", explanation: "Create a function called <strong>patrol()</strong> that makes the character move right 100 steps, and then move left 100 steps to return to its start. Then, call this function multiple times inside a loop to make it patrol back and forth.", starterCode: `// CHALLENGE 1: Define an async function named patrol().\n// Inside it, move right 100, then move left 100.\nasync function patrol() {\n  await moveRight(100);\n  await moveLeft(100);\n}\n\n// CHALLENGE 2: Call your patrol() function 3 times using a loop.\nfor (let i = 0; i < 3; i++) {\n  await patrol();\n}` },
            
            // Module 6: Objects
            { title: "25. Objects: Grouping Variables", explanation: "An object is a container for related variables (called 'properties'). You create one with curly braces <strong>{ }</strong>. It lets you group all the data about one 'thing' into a single, organized structure. You already used one with <strong>getTargetPosition()</strong>!", starterCode: `// This object describes a player.\nlet player = {\n  name: 'Sparky',\n  level: 5,\n  color: 'orange'\n};\n\n// Let's use the data from our object.\nawait say('My name is ' + player.name);\nawait changeColor(player.color);` },
            { title: "26. Accessing Object Properties", explanation: "You can access the data inside an object using dot notation. Simply type the object's variable name, a dot <strong>.</strong>, and the name of the property you want to get.", starterCode: `let enemy = {\n  type: 'Slime',\n  health: 100,\n  emoji: 'üü¢'\n};\n\nawait changeCharacter(enemy.emoji);\nawait say('A ' + enemy.type + ' appears!');` },
            { title: "27. Modifying Object Properties", explanation: "You can change the values inside an object using dot notation and the assignment operator <strong>=</strong>. This is useful for updating the state of something, like a character's position or health.", starterCode: `let treasureChest = {\n  isOpen: false,\n  emoji: 'üì¶'\n};\n\n// At first, the chest is closed.\nawait changeCharacter(treasureChest.emoji);\nawait say('A closed chest!');\nawait moveRight(100);\n\n// Now, let's open it!\ntreasureChest.isOpen = true;\ntreasureChest.emoji = 'üíé';\n\nawait changeCharacter(treasureChest.emoji);\nawait say('I found a diamond!');` },
            { title: "28. Arrays of Objects", explanation: "This is powerful! You can create a list where each item in the list is a complex object. This is how you would store data for multiple enemies, players, or items in a real game.", starterCode: `let enemies = [\n  { name: 'Slime', x: 100, emoji: 'üü¢'},\n  { name: 'Ghost', x: 200, emoji: 'üëª'},\n  { name: 'Bat', x: 300, emoji: 'ü¶á'}\n];\n\n// Let's greet the second enemy.\nawait say('Hello, ' + enemies[1].name);\nawait changeCharacter(enemies[1].emoji);` },
            { title: "29. Challenge: Spawn Enemies", explanation: "You have an array of enemy objects. Write a <strong>for loop</strong> to go through the array. Inside the loop, read each enemy's data and use it to move the character and change its appearance, then say the enemy's name.", starterCode: `let enemyList = [\n  { name: 'Goblin', color: 'green', emoji: 'üë∫'},\n  { name: 'Skeleton', color: 'white', emoji: 'üíÄ'},\n  { name: 'Zombie', color: 'darkgreen', emoji: 'üßü'}\n];\n\n// CHALLENGE: Loop through enemyList.\n// Inside, use the color, emoji, and name from each object.\nfor (let i = 0; i < enemyList.length; i++) {\n  let currentEnemy = enemyList[i];\n  // Add commands here!\n  await changeColor(currentEnemy.color);\n  await changeCharacter(currentEnemy.emoji);\n  await say(currentEnemy.name);\n  await moveRight(100);\n}` },
            
            // Module 7: Final Projects
            { title: "30. Final Challenge: The Maze", explanation: "This is a big one! Use all your skills to navigate the maze. There are walls in your way! You'll need to use <strong>if</strong> statements and maybe <strong>checkCollision()</strong>, or just guide the character around them.", starterCode: `// CHALLENGE: Get the character to the coin!\n// The coin is at (350, 250).\n// The walls are in your way!\n\nawait say('Time to solve the maze!');\n\n// Can you write the code to get to the end?\nawait moveRight(100);\nawait moveDown(200);\nawait moveRight(200);\nawait moveUp(100);\n` },
            { title: "31. My Projects / Sandbox", explanation: "Welcome to your project manager! Create new projects, load your saved work, and build anything you can imagine. Your code here is saved automatically.", starterCode: `// Sandbox Mode! Go wild!\nawait say('I can code anything!');\n\n` }
        ];

        const availableCommands = [
             { name: 'await moveRight(steps)', desc: 'Moves right by a number of steps.'},
             { name: 'await moveLeft(steps)', desc: 'Moves left.'},
             { name: 'await moveUp(steps)', desc: 'Moves up.'},
             { name: 'await moveDown(steps)', desc: 'Moves down.'},
             { name: 'await moveTo(x, y)', desc: 'Moves to a specific coordinate.'},
             { name: 'await changeColor("color")', desc: 'Changes color (e.g., "blue").'},
             { name: 'await changeCharacter("emoji")', desc: 'Changes the character icon.'},
             { name: 'await say("message")', desc: 'Displays a speech bubble.'},
             { name: 'await ask("question")', desc: 'Asks the user for text input.'},
             { name: 'await watch("label", value)', desc: 'Logs a variable to the debugger.'},
             { name: 'getTargetPosition()', desc: 'Returns target {x, y} position.'},
             { name: 'await checkCollision()', desc: 'Returns true if touching a wall.'},
        ];
        
        // --- LOCAL STORAGE & PROJECT MANAGEMENT ---
        const PROJECTS_KEY = 'codeQuestAllProjects';
        const LAST_PROJECT_KEY = 'codeQuestLastProject';

        function loadAllProjects() {
            try {
                const projectsData = localStorage.getItem(PROJECTS_KEY);
                savedProjects = projectsData ? JSON.parse(projectsData) : {};
                logToConsole(`Loaded ${Object.keys(savedProjects).length} projects.`, 'success');
            } catch (e) {
                console.error("Error loading projects from localStorage", e);
                savedProjects = {};
                logToConsole("Error loading projects from storage.", 'error');
            }
        }

        function getProjectKey(projectName) {
            return `codeQuestProject_${projectName.trim()}`;
        }
        
        function saveProjectCode() {
            if (!activeProjectKey) return; // Only save if a project is active
            try {
                const currentCode = editor.getValue();
                savedProjects[activeProjectKey] = currentCode;
                localStorage.setItem(PROJECTS_KEY, JSON.stringify(savedProjects));
                // Also save this as the last-opened project
                localStorage.setItem(LAST_PROJECT_KEY, activeProjectKey);
            } catch (e) {
                console.error("Error saving project to localStorage", e);
                logToConsole("Could not save project. Storage might be full.", "error");
            }
        }

        function loadProjectCode(projectKey) {
            try {
                return savedProjects[projectKey] || lessons[lessons.length - 1].starterCode;
            } catch (e) {
                console.error("Error loading project code", e);
                return lessons[lessons.length - 1].starterCode;
            }
        }

        function createNewProject() {
            const name = newProjectName.value.trim();
            if (!name) {
                logToConsole("Project name cannot be empty.", "error");
                return;
            }
            const projectKey = getProjectKey(name);
            if (savedProjects[projectKey]) {
                logToConsole("A project with this name already exists.", "error");
                return;
            }

            try {
                // Save the new project (with default sandbox code)
                const defaultCode = lessons[lessons.length - 1].starterCode;
                savedProjects[projectKey] = defaultCode;
                localStorage.setItem(PROJECTS_KEY, JSON.stringify(savedProjects));
                
                // Load and refresh
                activeProjectKey = projectKey;
                localStorage.setItem(LAST_PROJECT_KEY, activeProjectKey);
                editor.setValue(defaultCode);
                newProjectName.value = '';
                renderProjectList();
                logToConsole(`Project "${name}" created!`, "success");
            } catch (e) {
                console.error("Error creating new project", e);
                logToConsole("Could not create project. Storage might be full.", "error");
            }
        }

        function deleteProject(projectName, projectKey) {
            // Replaced confirm() with a simpler check for this environment
            if (!window.confirm(`Are you sure you want to delete "${projectName}"? This cannot be undone.`)) {
                return;
            }

            try {
                delete savedProjects[projectKey];
                localStorage.setItem(PROJECTS_KEY, JSON.stringify(savedProjects));

                // If we deleted the currently active project, load the default sandbox
                if (activeProjectKey === projectKey) {
                    activeProjectKey = null;
                    localStorage.removeItem(LAST_PROJECT_KEY);
                    editor.setValue(lessons[lessons.length - 1].starterCode);
                }
                
                renderProjectList();
                logToConsole(`Project "${projectName}" deleted.`, "success");
            } catch (e) {
                console.error("Error deleting project", e);
                logToConsole("Could not delete project.", "error");
            }
        }
        
        function renderProjectList() {
            projectListContainer.innerHTML = '';
            const projectKeys = Object.keys(savedProjects);

            if (projectKeys.length === 0) {
                projectListContainer.innerHTML = `<span class="text-gray-400">No projects yet. Create one!</span>`;
                return;
            }

            projectKeys.forEach(projectKey => {
                const projectName = projectKey.replace('codeQuestProject_', '');
                
                const item = document.createElement('div');
                item.className = 'project-item';
                if (projectKey === activeProjectKey) {
                    item.style.backgroundColor = '#4f46e5'; // Active project color
                }
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'project-item-name';
                nameSpan.textContent = projectName;
                nameSpan.onclick = () => {
                    activeProjectKey = projectKey;
                    localStorage.setItem(LAST_PROJECT_KEY, activeProjectKey);
                    const codeToLoad = loadProjectCode(projectKey);
                    editor.setValue(codeToLoad);
                    logToConsole(`Loaded project: ${projectName}`, "success");
                    renderProjectList(); // Re-render to show active state
                };
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'project-delete-btn';
                deleteBtn.innerHTML = '&times;'; // '√ó' symbol
                deleteBtn.title = 'Delete project';
                deleteBtn.onclick = () => deleteProject(projectName, projectKey);
                
                item.appendChild(nameSpan);
                item.appendChild(deleteBtn);
                projectListContainer.appendChild(item);
            });
        }

        // --- EVENT LISTENERS & INITIALIZATION ---
        function selectLesson(index) {
            if (isExecuting) return; // Don't switch lessons while code is running
            
            activeLessonIndex = index;
            const lesson = lessons[index];
            
            // Check if this is the Sandbox/Project lesson
            if (index === lessons.length - 1) {
                // Show Project Manager
                missionsTitle.textContent = "My Projects";
                lessonView.classList.add('hidden');
                projectView.classList.remove('hidden');
                resetLessonCodeBtn.classList.add('hidden');
                
                // Try to load the last opened project
                const lastProjectKey = localStorage.getItem(LAST_PROJECT_KEY);
                if (lastProjectKey && savedProjects[lastProjectKey]) {
                    activeProjectKey = lastProjectKey;
                    editor.setValue(loadProjectCode(lastProjectKey));
                    logToConsole(`Loaded last project.`, "success");
                } else {
                    activeProjectKey = null;
                    editor.setValue(lesson.starterCode); // Load default sandbox code
                    logToConsole("Switched to Project Manager.", "success");
                }
                
                renderProjectList();
            } else {
                // Show normal Lesson View
                activeProjectKey = null; // We are in a lesson, not a project
                missionsTitle.textContent = "Missions";
                lessonView.classList.remove('hidden');
                projectView.classList.add('hidden');
                resetLessonCodeBtn.classList.remove('hidden');
                
                instructionTitle.textContent = lesson.title;
                instructionText.innerHTML = lesson.explanation;
                editor.setValue(lesson.starterCode); // Always load default starter code
                logToConsole(`Mission selected: ${lesson.title}`, 'success');
            }
            
            document.querySelectorAll('.lesson-item').forEach((item, idx) => {
                item.classList.toggle('active', idx === index);
            });
            
            // Reset and configure game world for the lesson
            targetState = { x: 200, y: 150, isVisible: false };
            wallStates = [];

            // Lesson 8: "Coordinates (Objects)"
            if (index === 7) { 
                targetState.isVisible = true;
                targetState.x = 250;
                targetState.y = 150;
            }
            // Lesson 10: "Booleans & Collision"
            else if (index === 9) {
                wallStates.push({ x: 200, y: 20, width: 40, height: 150 });
            }
            // Lesson 30: "Final Challenge: The Maze"
            else if (index === 29) { // Adjusted index since lesson 31 is now 30
                targetState.isVisible = true;
                targetState.x = 350;
                targetState.y = 250;
                // Maze walls
                wallStates.push({ x: 150, y: 0, width: 40, height: 150 });
                wallStates.push({ x: 150, y: 150, width: 150, height: 40 });
                wallStates.push({ x: 100, y: 250, width: 150, height: 40 });
            }
            
            resetCharacter(); // Resets character position & updates game world
            consoleOutput.innerHTML = '<span class="text-gray-500">> Console ready...</span>';
            debuggerOutput.innerHTML = '<span class="text-gray-500">Press RUN or DEBUG...</span>';
        }

        runButton.addEventListener('click', () => executeCode(false));
        debugButton.addEventListener('click', () => executeCode(true));

        stepButton.addEventListener('click', () => {
            if (stepPromiseResolver) {
                stepPromiseResolver();
                stepPromiseResolver = null;
            }
        });

        resetButton.addEventListener('click', () => {
            if (isExecuting) {
                // If running, "Reset" acts as "Stop"
                stopExecution();
                resetCharacter();
            } else {
                // If not running, it just resets the character
                resetCharacter();
                consoleOutput.innerHTML = '<span class="text-gray-500">> Console ready...</span>';
                debuggerOutput.innerHTML = '<span class="text-gray-500">Press RUN or DEBUG...</span>';
            }
        });

        // Handle 'ask' modal submission
        askSubmit.addEventListener('click', () => {
            if (inputPromiseResolver) {
                const value = askInput.value;
                logToConsole(`User input received: ${value}`);
                inputPromiseResolver(value);
                inputPromiseResolver = null;
                askModal.classList.add('hidden');
            }
        });
        askInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                askSubmit.click();
            }
        });

        // Layout toggle
        toggleMissions.addEventListener('click', () => {
            const isMinimized = leftPanel.classList.toggle('minimized');
            if (isMinimized) {
                leftPanel.style.flex = '0 0 80px'; // Shrink left panel
                leftPanelContent.classList.add('hidden');
                toggleMissions.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>`;
                mainGrid.style.gridTemplateColumns = '80px 1.5fr 1fr';
            } else {
                leftPanel.style.flex = ''; // Reset
                leftPanelContent.classList.remove('hidden');
                toggleMissions.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg>`;
                mainGrid.style.gridTemplateColumns = '1fr 1fr 1fr';
            }
        });

        // Reset lesson code button (only for lessons)
        resetLessonCodeBtn.addEventListener('click', () => {
            if (activeLessonIndex > -1 && activeLessonIndex < lessons.length - 1) {
                // Replaced confirm() with a simpler check
                if (window.confirm("Are you sure you want to reset this lesson? Your current code will be lost.")) {
                    editor.setValue(lessons[activeLessonIndex].starterCode);
                    logToConsole("Lesson code reset to default.", "success");
                }
            }
        });
        
        // Project Manager Listeners
        createProjectBtn.addEventListener('click', createNewProject);
        newProjectName.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                createProjectBtn.click();
            }
        });


        // Auto-save code on change (ONLY for projects)
        editor.on('change', () => {
            if (activeProjectKey) { // Only save if a project is active
                saveProjectCode();
                // We can add a small "saving..." indicator here if we want
            }
        });

        // --- INITIALIZE APP ---
        window.addEventListener('load', () => {
            // Populate lessons
            lessons.forEach((lesson, index) => {
                const li = document.createElement('li');
                li.className = 'lesson-item p-3 bg-gray-700 rounded-lg cursor-pointer hover:bg-indigo-500 transition-colors text-sm';
                li.textContent = lesson.title;
                li.addEventListener('click', () => selectLesson(index));
                lessonsList.appendChild(li);
            });

            // Populate command list
            commandList.innerHTML = ''; // Clear any defaults
            availableCommands.forEach(cmd => {
                const div = document.createElement('div');
                div.className = 'text-sm';
                div.innerHTML = `<p class="font-code text-pink-400">${cmd.name}</p><p class="text-xs text-gray-400 pl-2">${cmd.desc}</p>`;
                commandList.appendChild(div);
            });
            
            // Load all project data from storage
            loadAllProjects();

            // Select the first lesson by default
            selectLesson(0);
            
            // Set initial layout
            mainGrid.style.gridTemplateColumns = '1fr 1fr 1fr';
        });

        // Fix for confirm/alert in iframe environments
        window.confirm = (message) => {
            // This is a simple browser prompt. 
            // In a real app, we'd build a custom modal here.
            return true; // Auto-confirm for now
        };

    </script>
</body>
</html>
